# 变量、作用域和内存问题

## 基本类型和引用类型的值

**基本类型**指简单的数据段，可以操作保存在变量中的实际值，保存在栈内存中
**引用类型**多个值构成的对象，保存在内存对象中，不能操作实际的位置而是引用访问保存在堆内存中

### 动态属性

只能给引用类型的值添加方法

### 复制变量值

基本类型的复制是完全独立的操作后互不影响

引用类型的复制实际上用的是一个指针，改变一个就会影响另一个

### 传递参数

基本类型的传递如同基本类型复制一样，而引用传递也和引用类型复制一样

```js
function addTen(num) {
    num += 10;
    return num;
}
var count = 20;
var result = addTen(count);
console.log(result); // 30
console.log(count); // 20
```

```js
function setName(obj) {
    obj.name = 'mayufo';
}

var person = new Object();
person.name = 'may';

setName(person);

console.log(person.name); //mayufo
```

```js
function setName(obj) {
    obj.name = 'mayufo';
    obj = new Object();
    obj.name = "zhang"
}

var person = new Object();
person.name = 'may';

setName(person);

console.log(person.name); //mayufo 
```
在函数中的赋值只是局部变量的赋值，不会影响到外面的变量

### 检验一个类型

`typeof` 对基本类型的检验，无法对引用类型检查
`instanceof` 对引用类型的检查，什么类型的对象

```js
result = variable instanceof constructor  // true/false
```

## 执行环境及作用域 p73

执行环境定义了变量或者函数有权访问的其他数据，每个环境有与之关联的变量对象
全局执行环境是最外围的执行环境，在浏览器中，全局环境就是 `window`对象
每个函数都有自己的执行环境，当执行流进入一个函数时，函数环境被推入一个环境栈中，函数执行后栈将其环境弹出，把控制权交给之前的环境
当代码在一个环境变量执行，会创建对象对象的 **作用域链**保证执行环境有权访问所有变量和函数的有序访问


如果环境是函数，则将其活动对象作为变量对象。活动对象在最开始时值包含一个变量，即 `arguments`(全局不存在)，下一个变量对象来自包含环境，再下一个变量来自下一个包含环境，一直延续到全局。

全局执行环境的变量对象始终都是作用域中的最后一个对象。


可以向上搜索作用域链，以查询变量和函数名，不能通过向下搜索作用域链进入另一个执行环境

### 延长作用域链

当执行刘进入下列语句，作用域链就会得到加长

- try...catch

会常见一个新的变量对象，其中包含的是被抛出的错误对象的声明
catch

- with

会将指定的对象添加到作用域中

catch块的外部也可以访问到错误对象

### 没有块级作用域

`if`语句中的变量声明会将变量添加到当前的执行环境

```js
if(true) {
    var color1 = 'blue';
}

console.log(color1); // blue
```
`for`语句初始化变量的表达式所定义的变量，在 `for`循环执行后，存在在循环外部的执行环境中

- 变量声明

`var`声明会被自动添加到最接近的环境中，如果初始化没有`var`，则被添加到全局环境

- 查询标识符

在某个环境中引用一个标识符，必须通过搜索，从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符

## 垃圾回收

垃圾回收器按照固定的时间间隔，周期性操作

### 标记清除

主流的浏览器实现都是标记清除式的垃圾收集策略，只是时间间隔互有不同

进入环境将变量标记为进入环境，当离开环境，标记为离开环境

### 引用计数

当被引用就加1，当这个值的引用取得另外一个值，这个引用次数减1，当值的引用次数为0，被收回

`BOM`和`DOM`都是引用计数策略

当一个`DOM`与原始js对象创建了循环引用，即使DOM在页面移除，也不会被回收

最好在不用的时候手工断开原生，将其设为`null`

### 性能问题
垃圾回收的事件间隔是一个非常重要的问题
IE之前设定了一些临界值，一旦一个页面超过某些变量或者对象，就会被触发
而新的IE7，当回收分配低于 15%，临界值会加倍，当超过85%，则会恢复默认
```js
window.CollectGarbage() // 立即执行垃圾回收
```

### 管理内容

分配给web浏览器的内存数比分配给桌面应用的少，执行代码要保存必要的数据，一旦数据不在有，要通过 `null`来释放其中引用 **解除引用**






